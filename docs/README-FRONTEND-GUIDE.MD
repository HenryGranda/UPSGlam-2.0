ğŸ¯ 0. Arquitectura general del frontend
â—	Capas lÃ³gicas:

â—‹	api / services: funciones que llaman a los endpoints (/auth/..., /feed, etc.).

â—‹	stores / state / blocs: manejan estado global (usuario logueado, feed, etc.).

â—‹	ui / screens: pantallas y componentes.

â—	Estado global mÃ­nimo:

â—‹	currentUser: User | null

â—‹	authToken: string | null (idToken)

â—‹	feed: List<Post>

â—‹	selectedPost: Post?

â—	URL base de la API (configurable):

â—‹	Ej: BASE_URL = http://<ip-local>:8080

________________________________________
1. MÃ³dulo AUTH (login / registro / sesiÃ³n)
1.1. Pantallas
â—	Splash Screen

â—‹	Revisa si hay authToken guardado (SecureStorage/SharedPrefs).

â—‹	Si hay token:

â– 	Llama GET /auth/me.

â– 	Si responde 200 â†’ va directo a Home.

â– 	Si 401 â†’ borra token y va a Login.

â—	Login Screen

â—‹	Inputs:

â– 	identifier (email/username/telÃ©fono).

â– 	password.

â—‹	Botones:

â– 	Login

â– 	Ir a Register

â—	Register Screen

â—‹	Inputs:

â– 	email

â– 	password

â– 	confirmPassword (validado solo en frontend).

â– 	fullName

â– 	username.

â—‹	Botones:

â– 	Register

â– 	Ir a Login

________________________________________
1.2. LÃ³gica con endpoints
ğŸ”¹ Login â€“ POST /auth/login
â—	Cuando el usuario presiona Login:

POST /auth/login
Content-Type: application/json

{
  "identifier": "pepito",
  "password": "12345678"
}

â—	Si 200 OK:

â—‹	Guardar:

â– 	authToken = token.idToken

â– 	currentUser = user

â—‹	Navegar a Home (Feed).

â—	Si 401:

â—‹	Mostrar mensaje: â€œUsuario o contraseÃ±a incorrectosâ€.

________________________________________
ğŸ”¹ Register â€“ POST /auth/register
â—	Cuando presiona Register despuÃ©s de validar password/confirm:

POST /auth/register
Content-Type: application/json

{
  "email":    "user@ups.edu.ec",
  "password": "12345678",
  "fullName": "Pepito PÃ©rez",
  "username": "pepito"
}

â—	Si 200:

â—‹	Igual que login â†’ guardar token + user y navegar a Home.

â—	Si 400 / 409:

â—‹	Mostrar mensaje segÃºn cÃ³digo:

â– 	EMAIL_ALREADY_IN_USE

â– 	USERNAME_ALREADY_IN_USE

â– 	etc.

________________________________________
ğŸ”¹ Cargar usuario al abrir la app â€“ GET /auth/me
â—	En Splash o al abrir Perfil:

GET /auth/me
Authorization: Bearer <idToken>

â—	Si 200:

â—‹	Actualizar currentUser en el state.

â—	Si 401:

â—‹	Borrar token y mandar a login.

________________________________________
2. MÃ³dulo PERFIL
2.1. Pantallas
â—	Profile Screen (mi perfil)

â—‹	Muestra:

â– 	photoUrl

â– 	username

â– 	fullName

â– 	bio

â– 	Stats opcionales (nÃºmero de posts, etc. si luego quieres).

â—‹	Botones:

â– 	Editar perfil

â– 	Cerrar sesiÃ³n

â—	Edit Profile Screen

â—‹	Inputs:

â– 	username

â– 	fullName

â– 	bio

â—‹	Botones:

â– 	Guardar

â– 	Cambiar foto (abre selector de imagen â†’ PUT avatar).

â—	Profile pÃºblico (de otros usuarios)

â—‹	Parecido a mi perfil, pero sin botones de editar, y sin â€œcerrar sesiÃ³nâ€.

â—‹	Navega desde el feed cuando tocas el username/imagen del user.

________________________________________
2.2. LÃ³gica con endpoints
ğŸ”¹ Ver mi perfil â€“ reutiliza GET /auth/me
Cada vez que entras a la pestaÃ±a Perfil:
â—	Si currentUser ya estÃ¡ en memoria:

â—‹	Solo renderizar.

â—	Opcional: refrescar con GET /auth/me para asegurar datos actualizados.

________________________________________
ğŸ”¹ Editar datos â€“ PATCH /users/me
â—	En Edit Profile, al presionar Guardar:

PATCH /users/me
Authorization: Bearer <idToken>
Content-Type: application/json

{
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "bio": "Ahora programando en PyCUDA ğŸ¤–"
}

â—	Si 200:

â—‹	Actualizar currentUser en memoria.

â—‹	Volver a pantalla de perfil.

â—	Si 400 (USERNAME_ALREADY_IN_USE):

â—‹	Mostrar error en el field username.

________________________________________
ğŸ”¹ Cambiar foto de perfil â€“ PUT /users/me/avatar
â—	Flujo:

â—‹	Usuario toca Cambiar foto.

â—‹	Front abre galerÃ­a / cÃ¡mara.

â—‹	Recibes un imageFile.

â—‹	Haces multipart/form-data:

PUT /users/me/avatar
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

image: archivo (foto)

â—	Si 200:

â—‹	Actualizar currentUser.photoUrl.

â—‹	Refrescar imagen en toda la app.

________________________________________
ğŸ”¹ Ver perfil pÃºblico â€“ GET /users/{userId}
â—	Desde el feed, al tocar un username de un post:

GET /users/uid123
Authorization: Bearer <idToken>   // o sin token si permites pÃºblico

â—	Mostrar pantalla con:

{
  "id": "uid123",
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://...",
  "bio": "..."
}

________________________________________
3. MÃ³dulo FEED + POSTS
3.1. Pantallas
â—	Home / Feed Screen

â—‹	Lista tipo Instagram:

â– 	Avatar + username.

â– 	Imagen (imageUrl).

â– 	DescripciÃ³n.

â– 	Likes & comments count.

â– 	Iconos:

â– 	â¤ï¸ like/unlike.

â– 	ğŸ’¬ comentarios (abre panel inferior).

â—‹	Scroll infinito:

â– 	Cuando llega cerca del final â†’ GET /feed?page=....

â—	Post Detail Screen (opcional)

â—‹	Si quieres pantalla completa de un post.

â—‹	Usa GET /posts/{postId} si necesitas data extra.

________________________________________
3.2. LÃ³gica con endpoints
ğŸ”¹ Cargar feed â€“ GET /feed
â—	Al entrar a Home por primera vez:

GET /feed?page=0&size=10
Authorization: Bearer <idToken>

â—	Guardas:

â—‹	feed.items como lista de posts.

â—	Para hacer scroll infinito:

â—‹	Llevar currentPage, totalItems.

â—‹	Cuando scrollEnd â†’ page++ â†’ vuelves a llamar GET /feed.

________________________________________
ğŸ”¹ Like / Unlike â€“ POST/DELETE /posts/{postId}/likes
â—	Cuando el usuario toca el corazÃ³n:

â—‹	Si likedByMe == false:

â– 	POST /posts/{id}/likes.

â—‹	Si likedByMe == true:

â– 	DELETE /posts/{id}/likes.

â—	En ambos casos, esperas respuesta:

{
  "postId": "postId123",
  "likesCount": 6,
  "likedByMe": true
}

â—	Actualizas solo ese post en el estado:

â—‹	Cambias likesCount y likedByMe.

Para que la app se sienta rÃ¡pida, puedes hacer optimistic update:
1.	Cambiar el corazÃ³n en UI primero.

2.	Mandar la peticiÃ³n.

3.	Si falla, revertir.

________________________________________
ğŸ”¹ Ver comentarios (panel inferior) â€“ GET /posts/{postId}/comments
â—	En el feed:

â—‹	Tocas icono ğŸ’¬ â†’ abres un bottom sheet:

â– 	Arriba: post resumen (username + mini imagen + descripciÃ³n).

â– 	Abajo: lista de comentarios + input.

â—	Al abrir el panel:

GET /posts/{postId}/comments?page=0&size=20
Authorization: Bearer <idToken>

â—	Renderizas items[] en una lista.

â—	Para cargar mÃ¡s (scroll dentro del panel) â†’ page++.

________________________________________
ğŸ”¹ Crear comentario â€“ POST /posts/{postId}/comments
â—	El usuario escribe y presiona â€œEnviarâ€:

POST /posts/{postId}/comments
Authorization: Bearer <idToken>
Content-Type: application/json

{
  "text": "QuÃ© buena foto ğŸ˜"
}

â—	Si 201:

â—‹	Insertas el comentario devuelto al final de la lista.

â—‹	Actualizas commentsCount del post en el feed (+1).

________________________________________
4. MÃ³dulo CREAR POST (cÃ¡mara + filtros + CUDA preview)
4.1. Pantallas
â—	Create Post Flow (tipo Instagram)

1.	Camera Screen

â—‹	Muestra:

â– 	Vista de cÃ¡mara.

â– 	Carrusel de filtros abajo (solo nombres).

â—‹	El usuario:

â– 	Cambia filtro seleccionado (UI local).

â– 	Toma la foto y confirma.

2.	Preview Screen (con filtro aplicado)

â—‹	Muestra:

â– 	Imagen filtrada que devuelve backend (imageUrl).

â– 	Input de descripciÃ³n.

â– 	BotÃ³n â€œPublicarâ€.

â—‹	AquÃ­ usas:

â– 	Estrategia preview + tempImageId.

________________________________________
4.2. Preview con CUDA â€“ POST /images/preview
â—	Cuando el usuario toma la foto en la cÃ¡mara con un filtro elegido:

â—‹	Front obtiene rawImageFile (jpeg/png).

â—‹	Llama:

POST /images/preview
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

image: archivo (foto original)
filter: "ups_logo"

â—	Backend responde:

{
  "tempImageId": "tmp-12345",
  "imageUrl": "https://.../temp/tmp-12345.jpg"
}

â—	La app:

â—‹	Navega a Preview Screen.

â—‹	Muestra la imagen usando imageUrl.

â—‹	Guarda en estado:

â– 	currentTempImageId = "tmp-12345".

â– 	currentFilter = "ups_logo".

________________________________________
4.3. Crear post definitivo â€“ POST /posts (JSON con tempImageId)
â—	En la pantalla de Preview, al tocar Publicar:

POST /posts
Authorization: Bearer <idToken>
Content-Type: application/json

{
  "tempImageId": "tmp-12345",
  "description": "Foto en la UPS ğŸ˜",
  "filter": "ups_logo"
}

â—	Backend responde con el Post completo:

{
  "id": "postId123",
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": null,
  "imageUrl": "https://.../posts/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 0,
  "commentsCount": 0,
  "likedByMe": true
}

â—	La app:

â—‹	Puede:

â– 	Insertar este post en la lista de feed en memoria en la parte superior, o

â– 	Volver al feed y hacer GET /feed de nuevo.

________________________________________
5. Manejo de sesiÃ³n / token en el frontend
â—	Cuando obtienes token.idToken:

â—‹	Guardarlo en storage seguro (SecureStorage / SharedPreferences).

â—	Todas las peticiones al backend:

â—‹	AÃ±adir header:

Authorization: Bearer <idToken>

â—	Si recibes 401 UNAUTHORIZED:

â—‹	Redireccionar a Login.

â—‹	Borrar token de disco.


2ï¸âƒ£ Flujo final del usuario (de punta a punta)
Imagina el camino tÃ­pico del usuario:
1. Abrir la app â€“ Splash Screen
1.	La app arranca en Splash.

2.	Revisa si hay un idToken guardado en el dispositivo.

3.	Si hay token:

â—‹	Llama GET /auth/me.

â—‹	Si responde 200 â†’ guarda el usuario en memoria â†’ navega a Home / Feed.

â—‹	Si responde 401 â†’ borra token â†’ navega a Login.

4.	Si no hay token â†’ directo a Login.

________________________________________
2. Login / Registro
Login
1.	Usuario ve pantalla Login con:

â—‹	identifier (email / username / telÃ©fono).

â—‹	password.

Pulsa Login â†’ front llama:

 POST /auth/login
2.	
3.	Si 200:

â—‹	Guarda token.idToken en storage.

â—‹	Guarda user (id, username, photoUrlâ€¦) en memoria.

â—‹	Navega a Home / Feed.

4.	Si 401:

â—‹	Muestra â€œUsuario o contraseÃ±a incorrectosâ€.

Registro
1.	Desde Login puede tocar â€œCrear cuentaâ€.

2.	En pantalla Register llena:

â—‹	email, password, confirmPassword, fullName, username.

3.	El front valida que password == confirmPassword.

Llama:

 POST /auth/register
4.	
5.	Si 200:

â—‹	Igual que login â†’ guarda token y user.

â—‹	Navega a Home / Feed.

6.	Si 400 / 409:

â—‹	Muestra errores de EMAIL_ALREADY_IN_USE o USERNAME_ALREADY_IN_USE.

________________________________________
3. Home / Feed (timeline principal)
1.	Al entrar en Home:

Llama:

 GET /feed?page=0&size=10
â—‹	
â—‹	Renderiza la lista de posts, cada card con:

â– 	Avatar + username (tap para ir a perfil pÃºblico).

â– 	Imagen (imageUrl).

â– 	DescripciÃ³n.

â– 	Likes & comments count.

â– 	Icono â¤ï¸ (estado segÃºn likedByMe).

â– 	Icono ğŸ’¬ para comentarios.

2.	Cuando el usuario hace scroll:

â—‹	Si llega al final de la lista:

â– 	Llama GET /feed?page=1, luego page=2, etc.

â—‹	AÃ±ade los nuevos posts a la lista.

3.	Al tocar el username:

â—‹	Navega a Perfil pÃºblico.

â—‹	Usa GET /users/{userId}.

________________________________________
4. Likes y comentarios desde el feed
Like / Unlike
â—	El usuario toca el corazÃ³n:

â—‹	Si likedByMe == false:

â– 	Front puede inmediatamente cambiar a rojo (optimistic).

â– 	Llama POST /posts/{postId}/likes.

â—‹	Si likedByMe == true:

â– 	Llama DELETE /posts/{postId}/likes.

â—	Actualiza likesCount y likedByMe en el post.

Comentarios
1.	El usuario toca el icono ğŸ’¬.

2.	Se abre un bottom sheet / panel inferior:

â—‹	Arriba: info resumida del post.

â—‹	Abajo: lista de comentarios + input de texto.

La app llama:

 GET /posts/{postId}/comments?page=0&size=20
3.	
4.	Renderiza comentarios. Si hace scroll en el panel:

â—‹	page=1, page=2, etc. si quieres paginaciÃ³n.

5.	Cuando escribe un comentario y toca â€œEnviarâ€:

Llama:

 POST /posts/{postId}/comments
â—‹	
â—‹	Si 201:

â– 	Agrega el comentario a la lista.

â– 	Sube en memoria commentsCount del post.

________________________________________
5. Crear post (cÃ¡mara + filtros PyCUDA)
5.1. Abrir cÃ¡mara
1.	En Home, el usuario toca el botÃ³n â€œ+â€.

2.	Navega a Camera Screen:

â—‹	Vista de cÃ¡mara.

â—‹	Carrusel de filtros (solo UI por ahora: ups_logo, gaussian, etc.).

3.	El usuario selecciona un filtro y toma foto.

5.2. Enviar a preview CUDA â€“ POST /images/preview
4.	Al confirmar la foto:

Front envÃ­a:

 POST /images/preview
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

image: archivo de la cÃ¡mara
filter: "ups_logo"
â—‹	
5.	Backend:

â—‹	Llama PyCUDA.

â—‹	Sube imagen filtrada a Storage en temp/.

Devuelve:

 {
  "tempImageId": "tmp-12345",
  "imageUrl": "https://.../temp/tmp-12345.jpg"
}
â—‹	
6.	La app:

â—‹	Navega a Preview Screen.

â—‹	Muestra la imagen filtrada (imageUrl).

â—‹	Guarda tempImageId y filter en estado local.

5.3. Publicar post definitivo â€“ POST /posts
7.	En Preview Screen:

â—‹	El usuario escribe una descripciÃ³n.

â—‹	Toca Publicar.

Front manda:

 POST /posts
Authorization: Bearer <idToken>
Content-Type: application/json

{
  "tempImageId": "tmp-12345",
  "description": "Foto en la UPS ğŸ˜",
  "filter": "ups_logo"
}
8.	
9.	Backend:

â—‹	Mueve imagen de temp/ â†’ posts/.

â—‹	Crea documento en Firestore.

â—‹	Devuelve el Post completo.

10.	Front:

â—‹	Inserta ese post al inicio del feed en memoria o

â—‹	Navega al feed y hace otro GET /feed.

________________________________________
6. Perfil y ediciÃ³n
Ver mi perfil
1.	Usuario abre pestaÃ±a Perfil.

2.	La app usa currentUser de memoria.

3.	Opcionalmente refresca con GET /auth/me.

Editar perfil (texto)
1.	Tocando â€œEditar Perfilâ€ â†’ EditProfile Screen.

2.	Cambia username, fullName, bio.

3.	Toca Guardar:

â—‹	PATCH /users/me.

4.	Si 200:

â—‹	Actualiza currentUser.

â—‹	Vuelve a pantalla de Perfil.

Cambiar avatar
1.	En Edit Profile:

â—‹	Toca â€œCambiar fotoâ€.

2.	Abre cÃ¡mara/galerÃ­a.

3.	EnvÃ­a PUT /users/me/avatar con la image.

4.	Si 200:

â—‹	Actualiza photoUrl en currentUser.

â—‹	Refresca la UI.

Logout
1.	BotÃ³n â€œCerrar sesiÃ³nâ€.

2.	La app:

â—‹	Borra idToken del storage.

â—‹	Limpia currentUser y estados.

â—‹	Navega a Login.

________________________________________
3ï¸âƒ£ Arquitectura propuesta del frontend
Te propongo algo limpio y sencillo, estilo por features, que sirve igual para Flutter, Ionic o Android nativo.
3.1. Estructura de carpetas (ejemplo tipo Flutter)
lib/
â”œâ”€â”€ main.dart
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ api_config.dart         # BASE_URL, timeouts
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â””â”€â”€ api_client.dart         # cliente HTTP base
â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â””â”€â”€ auth_storage.dart       # guarda y lee idToken
â”‚   â””â”€â”€ models/
â”‚       â”œâ”€â”€ user.dart               # User (igual al JSON del backend)
â”‚       â”œâ”€â”€ post.dart               # Post
â”‚       â””â”€â”€ comment.dart            # Comment
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”‚   â””â”€â”€ auth_api.dart       # llama a /auth/register, /auth/login, /auth/me
â”‚   â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”‚   â””â”€â”€ auth_controller.dart# maneja currentUser + token + isLoading
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â”œâ”€â”€ login_screen.dart
â”‚   â”‚       â”œâ”€â”€ register_screen.dart
â”‚   â”‚       â””â”€â”€ splash_screen.dart
â”‚   â”œâ”€â”€ profile/
â”‚   â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”‚   â””â”€â”€ profile_api.dart    # PATCH /users/me, PUT avatar, GET /users/{id}
â”‚   â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”‚   â””â”€â”€ profile_controller.dart
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â”œâ”€â”€ profile_screen.dart
â”‚   â”‚       â””â”€â”€ edit_profile_screen.dart
â”‚   â”œâ”€â”€ feed/
â”‚   â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”‚   â””â”€â”€ feed_api.dart       # GET /feed
â”‚   â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”‚   â””â”€â”€ feed_controller.dart# lista de posts, pÃ¡gina, loading, etc.
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â”œâ”€â”€ feed_screen.dart
â”‚   â”‚       â””â”€â”€ widgets/
â”‚   â”‚           â””â”€â”€ post_card.dart
â”‚   â”œâ”€â”€ post/
â”‚   â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”‚   â””â”€â”€ post_api.dart       # POST /posts, DELETE /posts/{id}, GET /posts/{id}
â”‚   â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”‚   â”œâ”€â”€ create_post_controller.dart
â”‚   â”‚   â”‚   â””â”€â”€ post_detail_controller.dart
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â”œâ”€â”€ camera_screen.dart
â”‚   â”‚       â”œâ”€â”€ preview_screen.dart
â”‚   â”‚       â””â”€â”€ post_detail_screen.dart
â”‚   â”œâ”€â”€ likes_comments/
â”‚   â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”‚   â””â”€â”€ interaction_api.dart# likes + comments endpoints
â”‚   â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”‚   â”œâ”€â”€ like_controller.dart
â”‚   â”‚   â”‚   â””â”€â”€ comments_controller.dart
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â””â”€â”€ comments_bottom_sheet.dart
â””â”€â”€ widgets/
    â””â”€â”€ common_button.dart          # componentes compartidos

3.2. Capas por feature
Para cada feature (auth, profile, feed, post, likes_comments) tienes:
â—	data/:

â—‹	Llama a la API usando api_client.

â—‹	Un archivo por grupo de endpoints: auth_api.dart, feed_api.dart, etc.

â—	state/:

â—‹	Controladores / BLoC / Riverpod providers.

â—‹	Encapsulan:

â– 	loading, error, data, actions.

â—	ui/:

â—‹	Pantallas y widgets.

â—‹	Solo consumen el state y llaman acciones (no conocen endpoints).

3.3. Principios que estarÃ­as cumpliendo
â—	Separation of concerns:

â—‹	UI no conoce URLs ni tokens â†’ solo llama a mÃ©todos del controller.

â—	Reusabilidad:

â—‹	models/ compartidos entre features (User, Post, Comment).

â—	ConfiguraciÃ³n centralizada:

â—‹	BASE_URL en core/config/api_config.dart.

â—‹	Manejo de token en core/storage/auth_storage.dart.

â—	Testabilidad:

â—‹	Puedes testear auth_api o feed_controller mockeando el api_client.













































Auth / Perfil
â—	POST /auth/register â†’ pantalla Register âœ”

â—	POST /auth/login â†’ pantalla Login âœ”

â—	GET /auth/me â†’ Splash / Perfil / refrescar user âœ”

â—	PATCH /users/me â†’ Editar perfil (texto) âœ”

â—	PUT /users/me/avatar â†’ Cambiar foto de perfil âœ”

â—	GET /users/{userId} â†’ Ver perfil de otro usuario desde el feed âœ”

Posts / Feed / ImÃ¡genes
â—	GET /feed â†’ Home / Feed con scroll infinito âœ”

â—	POST /images/preview â†’ pantalla de Preview con filtro CUDA âœ”

â—	POST /posts (con tempImageId) â†’ Publicar post âœ”

â—	POST /posts (multipart directo) â†’ si algÃºn dÃ­a quieres modo sin preview, tambiÃ©n âœ”

â—	GET /posts/{postId} â†’ opcional para pantalla de detalle de post ğŸ”¸

â—	DELETE /posts/{postId} â†’ opcional para botÃ³n â€œeliminar postâ€ del dueÃ±o ğŸ”¸

Likes
â—	POST /posts/{postId}/likes â†’ botÃ³n de like âœ”

â—	DELETE /posts/{postId}/likes â†’ unlike âœ”

â—	GET /posts/{postId}/likes â†’ opcional pantalla â€œa quiÃ©n le gusta estoâ€ ğŸ”¸

Comments
â—	GET /posts/{postId}/comments â†’ panel inferior con comentarios âœ”

â—	POST /posts/{postId}/comments â†’ enviar comentario âœ”

â—	DELETE /posts/{postId}/comments/{commentId} â†’ opcional borrar comentario propio ğŸ”¸

â—	GET /posts/{postId}/comments/stream â†’ solo si te quieres lucir con tiempo real PRO ğŸ”¸

Todo lo core de la app tipo Instagram estÃ¡ cubierto. Lo marcado con ğŸ”¸ es opcional a nivel UI.

