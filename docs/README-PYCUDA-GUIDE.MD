PyCUDA Service ‚Äì Procesamiento de Im√°genes en GPU ‚öôÔ∏èüß†
1. Descripci√≥n general
El PyCUDA Service es un microservicio HTTP, escrito en Python + PyCUDA, que se encarga √∫nicamente de:
‚óè	Recibir una imagen (JPEG/PNG) por HTTP.

‚óè	Aplicar un filtro de convoluci√≥n en GPU (CUDA).

‚óè	Devolver la imagen filtrada en el mismo formato (bytes de imagen).

No sabe nada de usuarios, posts, likes, Firestore ni Firebase.
 Solo hace: imagen de entrada ‚Üí GPU ‚Üí imagen de salida.
________________________________________
2. Endpoints
2.1. POST /filters/{filterName}
Aplica un filtro a una imagen.
‚óè	URL (interno, llamado desde post-service)
 POST http://pycuda-service:5000/filters/{filterName}

‚óè	Path param:

‚óã	filterName (string) ‚Äì nombre l√≥gico del filtro, por ejemplo:

‚ñ†	gaussian

‚ñ†	sharpen

‚ñ†	edge_detect

‚ñ†	emboss

‚ñ†	ups_logo

‚ñ†	ups_color

‚óè	Headers:

Content-Type: image/jpeg      # o image/png
Accept: image/jpeg            # o image/png, idealmente mismo formato que env√≠as

‚óè	Body (request):

‚óã	Bytes de la imagen (no JSON, no multipart).

‚óã	El cliente (post-service) env√≠a la imagen cruda.

‚óè	Response (200 OK):

Content-Type: image/jpeg
Body: [bytes de la imagen ya filtrada]

‚óè	Errores:

‚óè	400 BAD_REQUEST

‚óã	filterName no existe.

‚óã	Formato de imagen inv√°lido.

‚óè	500 INTERNAL_SERVER_ERROR

‚óã	Error en kernel CUDA, memoria GPU, etc.

Ejemplo conceptual de llamada (desde post-service ‚Äì cURL):
curl -X POST "http://pycuda-service:5000/filters/gaussian" \
  -H "Content-Type: image/jpeg" \
  --data-binary "@input.jpg" \
  -o "output_gaussian.jpg"

________________________________________
3. Cat√°logo de filtros
Puedes ajustar los nombres exactos, pero la idea es tener m√≠nimo:
‚óè	4 filtros vistos en clase.

‚óè	2 filtros creativos, uno relacionado con la UPS.

Filtro: gaussian
‚óè	Tipo: convoluci√≥n blur.

‚óè	Efecto: desenfoque suave (suaviza ruido en la imagen).

‚óè	Kernel t√≠pico 3x3 o 5x5 (ejemplo conceptual):

[ 1  2  1
  2  4  2
  1  2  1 ] / 16

Filtro: sharpen
‚óè	Tipo: realce de bordes.

‚óè	Efecto: la imagen se ve m√°s n√≠tida.

‚óè	Kernel t√≠pico:

[  0  -1   0
  -1   5  -1
   0  -1   0 ]

Filtro: edge_detect
‚óè	Tipo: detecci√≥n de bordes (estilo Sobel/Laplace).

‚óè	Efecto: resalta contornos.

Ejemplo: Laplaciano
[ -1  -1  -1
  -1   8  -1
  -1  -1  -1 ]

Filtro: emboss (creativo 1)
‚óè	Tipo: relieve.

‚óè	Efecto: apariencia ‚Äúen relieve‚Äù (como grabado).

Ejemplo kernel:
[ -2  -1   0
  -1   1   1
   0   1   2 ]

Filtro: ups_logo (creativo 2, UPS requerido)
‚óè	Tipo: convoluci√≥n + overlay.

‚óè	Idea posible:

‚óã	Aplicar un suavizado ligero.

‚óã	Superponer el logo de la UPS en una esquina (o patr√≥n).

‚óè	Implementaci√≥n simple:

‚óã	Filtro base (ej. gaussian) + escribir el logo en una regi√≥n fija de la imagen.

‚óã	El logo podr√≠a ser una peque√±a matriz pre-cargada o aplicar un patr√≥n de color.

Filtro: ups_color (creativo 3, opcional extra)
‚óè	Tipo: colorizaci√≥n.

‚óè	Efecto: aplicar un tinte con los colores de la UPS (ej. dorado/marr√≥n).

‚óè	Implementaci√≥n:

‚óã	Transformar a escala de grises.

‚óã	Aplicar una funci√≥n que desplace la paleta de colores hacia el color corporativo.

En el doc del PyCUDA puedes hacer una tablita tipo:
| filterName | Tipo        | Descripci√≥n visual                 |
|-----------|-------------|-------------------------------------|
| gaussian  | convoluci√≥n | Desenfoque suave                   |
| sharpen   | convoluci√≥n | Imagen m√°s n√≠tida                  |
| edge_detect | convoluci√≥n | Resalta bordes y contornos      |
| emboss    | convoluci√≥n | Efecto de relieve                  |
| ups_logo  | creativo    | Blur + logo UPS superpuesto        |
| ups_color | creativo    | Tinte de color con paleta de la UPS|

________________________________________
4. Arquitectura interna del PyCUDA Service
Propuesta de estructura de carpetas:
pycuda-service/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ app.py                  # Punto de entrada (Flask/FastAPI)
    ‚îú‚îÄ‚îÄ api/
    ‚îÇ   ‚îî‚îÄ‚îÄ filters_controller.py  # Define POST /filters/{filterName}
    ‚îú‚îÄ‚îÄ core/
    ‚îÇ   ‚îú‚îÄ‚îÄ cuda_context.py     # Inicializa contexto CUDA, device, etc.
    ‚îÇ   ‚îú‚îÄ‚îÄ kernels/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gaussian.cu
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sharpen.cu
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edge_detect.cu
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emboss.cu
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ups_logo.cu     # si lo haces con kernel personalizado
    ‚îÇ   ‚îî‚îÄ‚îÄ filter_service.py   # L√≥gica para escoger filtro y ejecutar kernel
    ‚îî‚îÄ‚îÄ utils/
        ‚îú‚îÄ‚îÄ image_io.py         # Bytes ‚Üî np.ndarray, RGB/GRAY
        ‚îî‚îÄ‚îÄ config.py

4.1. app.py
‚óè	Levanta el servidor HTTP (Flask o FastAPI).

‚óè	Registra la ruta POST /filters/{filterName}.

Pseudoc√≥digo:
from fastapi import FastAPI, Path, Response, HTTPException, Request
from core.filter_service import apply_filter

app = FastAPI()

@app.post("/filters/{filter_name}")
async def apply_filter_endpoint(
    filter_name: str = Path(...),
    request: Request = None
):
    # Leer bytes de la imagen del body
    image_bytes = await request.body()

    try:
        output_bytes = apply_filter(filter_name, image_bytes)
    except UnknownFilterError:
        raise HTTPException(status_code=400, detail="Unknown filter")
    except Exception:
        raise HTTPException(status_code=500, detail="CUDA error")

    return Response(content=output_bytes, media_type="image/jpeg")

4.2. core/filter_service.py
‚óè	Se encarga de:

‚óã	Convertir bytes ‚Üí array (via image_io.py).

‚óã	Mandar el array al kernel CUDA correcto.

‚óã	Recibir resultado y convertir de vuelta a bytes.

Pseudoc√≥digo:
from utils.image_io import bytes_to_array, array_to_bytes
from core.kernels.gaussian import gaussian_filter_gpu
from core.kernels.sharpen import sharpen_filter_gpu
# etc.

FILTERS = {
    "gaussian": gaussian_filter_gpu,
    "sharpen": sharpen_filter_gpu,
    "edge_detect": edge_detect_filter_gpu,
    "emboss": emboss_filter_gpu,
    "ups_logo": ups_logo_filter_gpu,
    "ups_color": ups_color_filter_gpu,
}

class UnknownFilterError(Exception):
    pass

def apply_filter(filter_name: str, image_bytes: bytes) -> bytes:
    if filter_name not in FILTERS:
        raise UnknownFilterError()

    img = bytes_to_array(image_bytes)          # np.ndarray (H, W, C)
    kernel_fn = FILTERS[filter_name]          # funci√≥n que ejecuta kernel en GPU
    out_img = kernel_fn(img)                  # np.ndarray filtrado
    out_bytes = array_to_bytes(out_img)       # JPEG bytes

    return out_bytes

4.3. Kernels CUDA
Cada archivo .cu define un kernel CUDA.
Ejemplo conceptual gaussian.cu:
extern "C"
__global__ void gaussian_filter(
    const unsigned char* input,
    unsigned char* output,
    int width,
    int height,
    int channels
) {
    // √≠ndice global (x, y) y aplicar kernel 3x3 sobre input
}

Y en Python (core/kernels/gaussian.py) usas PyCUDA para:
‚óè	Compilar el kernel.

‚óè	Lanzarlo con los bloques/hilos adecuados.

‚óè	Copiar datos de/to GPU.

________________________________________
5. Flujo de datos con el resto de microservicios
5.1. Estrategia 1 ‚Äì Procesamiento directo en POST /posts (simple)
1.	App m√≥vil:

‚óã	Hace foto.

‚óã	Llama al backend: POST /posts (multipart) con image + filter.

2.	API Gateway:

‚óã	Redirige a post-service.

3.	post-service:

‚óã	PostHandler.createPostMultipart llama a ImageService.processAndUploadMultipart(...).

‚óã	ImageService:

‚ñ†	Extrae image y filter.

Llama a PyCUDA:

 POST http://pycuda-service:5000/filters/{filter}
Body: bytes de imagen
‚ñ†	
‚ñ†	Recibe los bytes filtrados.

‚ñ†	Sube la imagen a Storage (posts/{postId}.jpg).

‚óã	Crea documento en posts/{postId} en Firestore.

‚óã	Devuelve el PostResponse a la app.

4.	App m√≥vil:

‚óã	Muestra el post y/o actualiza el feed.

5.2. Estrategia 2 ‚Äì Preview (/images/preview + tempImageId)
1.	App m√≥vil:

‚óã	Toma foto.

‚óã	Llama a POST /images/preview con image + filter.

2.	post-service ‚Üí PyCUDA (igual que arriba):

‚óã	PyCUDA aplica el filtro.

‚óã	post-service sube imagen filtrada a Storage temp/{tempImageId}.jpg.

‚óã	Devuelve a la app:

{
  "tempImageId": "tmp-12345",
  "imageUrl": "https://.../temp/tmp-12345.jpg"
}
3.	
4.	App m√≥vil:

‚óã	Muestra la preview con la URL.

‚óã	Si el usuario confirma, hace POST /posts con:

{
  "tempImageId": "tmp-12345",
  "description": "...",
  "filter": "ups_logo"
}
5.	
6.	post-service:

‚óã	ImageService.moveTempToPost(tempImageId) mueve la imagen de temp/ a posts/.

‚óã	Crea el post en Firestore.

‚óã	Devuelve el PostResponse.

________________________________________
6. Resumen de lo que debe quedar en el doc de PyCUDA
Puedes dejar la secci√≥n as√≠ en tu README de backend / doc t√©cnico:
1.	Descripci√≥n del PyCUDA Service.

2.	Endpoint principal: POST /filters/{filterName} (request/respuesta).

3.	Tabla de filtros con nombre, tipo y descripci√≥n.

4.	Arquitectura interna:

‚óã	app.py

‚óã	api/filters_controller.py

‚óã	core/filter_service.py

‚óã	core/kernels/*.cu

‚óã	utils/image_io.py

5.	Flujo de datos:

‚óã	App ‚Üí Gateway ‚Üí post-service ‚Üí PyCUDA ‚Üí Storage ‚Üí Firestore ‚Üí App.

‚óã	Diferencia entre estrategia simple y estrategia con preview.

