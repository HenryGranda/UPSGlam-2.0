1. AUTH
Endpoints
â—	POST /auth/register

â—	POST /auth/login

â—	GET /auth/me

________________________________________
1.1. POST /auth/register
Campos del template REGISTER
â—	Email â†’ email

â—	Password â†’ password

â—	Confirm password â†’ (se valida solo en frontend, al backend llega un password)

â—	Full Name â†’ fullName

â—	Username â†’ username

________________________________________
Request (body JSON)
{
  "email": "user@ups.edu.ec",
  "password": "12345678",
  "fullName": "Pepito PÃ©rez",
  "username": "pepito"
}

Reglas mÃ­nimas sugeridas (validaciones)
â—	email: obligatorio, formato email.

â—	password: obligatorio, mÃ­nimo 6â€“8 caracteres.

â—	fullName: obligatorio, 2â€“80 caracteres.

â—	username: obligatorio, Ãºnico, sin espacios, solo letras/nÃºmeros/guion-bajo.

________________________________________
Response (200 OK)
Al registrarse, tambiÃ©n haces login automÃ¡tico devolviendo token:
{
  "user": {
    "id": "firebaseUid",
    "email": "user@ups.edu.ec",
    "username": "pepito",
    "fullName": "Pepito PÃ©rez",
    "photoUrl": null,
    "bio": null
  },
  "token": {
    "idToken": "JWT_FIREBASE_O_LO_QUE_EXPONGAS",
    "refreshToken": "REFRESH_TOKEN_OPCIONAL",
    "expiresIn": 3600
  }
}

________________________________________
Errores tÃ­picos
400 Bad Request

 { "code": "VALIDATION_ERROR", "message": "Email invÃ¡lido" }
â—	
409 Conflict

 { "code": "EMAIL_ALREADY_IN_USE", "message": "El email ya estÃ¡ registrado" }
 { "code": "USERNAME_ALREADY_IN_USE", "message": "El username ya estÃ¡ en uso" }
â—	
________________________________________
1.2. POST /auth/login
Campos en UI
â—	Phone number, username, or email

â—	Password

Para que sea flexible definimos:
{
  "identifier": "pepito",
  "password": "12345678"
}

identifier puede ser:
â—	un email ("user@ups.edu.ec")

â—	un username ("pepito")

â—	(opcional) un telÃ©fono ("+593...")

________________________________________
Request
{
  "identifier": "user@ups.edu.ec",
  "password": "12345678"
}

o
{
  "identifier": "pepito",
  "password": "12345678"
}

________________________________________
Response (200 OK)
Mismo formato que register:
{
  "user": {
    "id": "firebaseUid",
    "email": "user@ups.edu.ec",
    "username": "pepito",
    "fullName": "Pepito PÃ©rez",
    "photoUrl": null,
    "bio": null
  },
  "token": {
    "idToken": "JWT_FIREBASE_O_LO_QUE_EXPONGAS",
    "refreshToken": "REFRESH_TOKEN_OPCIONAL",
    "expiresIn": 3600
  }
}

________________________________________
Errores tÃ­picos
401 Unauthorized

 { "code": "INVALID_CREDENTIALS", "message": "Usuario o contraseÃ±a incorrectos" }
â—	
________________________________________
1.3. GET /auth/me
Este endpoint NO lleva body.
 El cliente solo manda el token:
GET /auth/me
Authorization: Bearer <idToken>

________________________________________
Response (200 OK)
Solo info de perfil (sin token):
{
  "id": "uid123",
  "email": "user@ups.edu.ec",
  "username": "pepito",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "bio": "Estudiante de la UPS y fan de CUDA ğŸ˜"
}

________________________________________
Errores
401 Unauthorized (token ausente o invÃ¡lido)

 { "code": "UNAUTHORIZED", "message": "Token invÃ¡lido o expirado" }
â—	
________________________________________
2. PERFIL DE USUARIO
2.1. Modelo de usuario (User)
Este es el JSON estÃ¡ndar de usuario:
{
  "id": "uid123",
  "email": "user@ups.edu.ec",
  "username": "pepito",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "bio": "Estudiante de la UPS y fan de CUDA ğŸ˜"
}

En Firestore:
â—	ColecciÃ³n: users

â—	Documento: users/{uid} con esos campos.

________________________________________
2.2. PATCH /users/me â€“ actualizar datos de perfil (texto)
Campos que puede cambiar:
â—	username

â—	fullName

â—	bio

Request
PATCH /users/me
Authorization: Bearer <idToken>
Content-Type: application/json

Body (ejemplo):
{
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "bio": "Ahora programando en PyCUDA ğŸ¤–"
}

Todos los campos son opcionales: solo se actualiza lo que venga en el JSON.
________________________________________
Response (200 OK)
{
  "id": "uid123",
  "email": "user@ups.edu.ec",
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "bio": "Ahora programando en PyCUDA ğŸ¤–"
}

________________________________________
Errores tÃ­picos
400 Bad Request

 { "code": "USERNAME_ALREADY_IN_USE", "message": "El username ya estÃ¡ en uso" }
â—	
â—	401 Unauthorized

â—	422 Unprocessable Entity (validaciÃ³n de longitud/formato de campos).

________________________________________
2.3. PUT /users/me/avatar â€“ actualizar foto de perfil
Request
PUT /users/me/avatar
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

Partes del form:
â—	image: archivo (foto nueva de perfil).

Conceptual:
{
  // + archivo 'image'
}

________________________________________
Flujo interno (backend)
1.	Valida token â†’ obtiene uid123.

2.	Sube la imagen a Firebase Storage:

â—‹	avatars/uid123.jpg

3.	Genera photoUrl pÃºblica.

4.	Actualiza users/{uid123} en Firestore con ese photoUrl.

5.	(Opcional) actualiza tambiÃ©n photoUrl en Firebase Auth.

________________________________________
Response (200 OK)
{
  "id": "uid123",
  "email": "user@ups.edu.ec",
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "bio": "Ahora programando en PyCUDA ğŸ¤–"
}

________________________________________
2.4. GET /users/{userId} â€“ perfil pÃºblico (opcional)
Para ver el perfil del autor de un post.
Request
GET /users/uid123
Authorization: Bearer <idToken>   // o pÃºblico, segÃºn decidas

Response (200 OK)
{
  "id": "uid123",
  "username": "pepito_cuda",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "bio": "Ahora programando en PyCUDA ğŸ¤–"
}

Nota: aquÃ­ puedes omitir email por privacidad.
________________________________________
3. POSTS & FEED
3.1. Modelo Post
Modelo estÃ¡ndar que devuelven todos los endpoints de posts/feed:
{
  "id": "postId123",
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg",
  "imageUrl": "https://firebasestorage.googleapis.com/ups/posts/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 5,
  "commentsCount": 2,
  "likedByMe": true
}

likedByMe indica si el usuario actual (segÃºn token) ya le dio like al post.
________________________________________
3.2. GET /feed â€“ lo primero que ve la app
Request
GET /feed?page=0&size=10
Authorization: Bearer <idToken>    // podrÃ­as permitirlo sin token, pero con token puedes calcular likedByMe

Query params:
â—	page: pÃ¡gina (empieza en 0).

â—	size: cuÃ¡ntos posts por pÃ¡gina.

________________________________________
Response (200 OK)
{
  "page": 0,
  "size": 10,
  "totalItems": 2,
  "items": [
    {
      "id": "postId123",
      "userId": "uid123",
      "username": "pepito",
      "userPhotoUrl": null,
      "imageUrl": "https://firebasestorage.googleapis.com/ups/postId123.jpg",
      "filter": "ups_logo",
      "description": "Foto en la UPS ğŸ˜",
      "createdAt": "2025-12-03T10:00:00Z",
      "likesCount": 5,
      "commentsCount": 2,
      "likedByMe": true
    },
    {
      "id": "postId122",
      "userId": "uid999",
      "username": "maria",
      "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/maria.jpg",
      "imageUrl": "https://firebasestorage.googleapis.com/ups/postId122.jpg",
      "filter": "gaussian",
      "description": "Proyecto CUDA",
      "createdAt": "2025-12-03T09:55:00Z",
      "likesCount": 1,
      "commentsCount": 0,
      "likedByMe": false
    }
  ]
}

________________________________________
3.3. POST /posts â€“ crear publicaciÃ³n (estrategia simple: subir foto directa)
Esta es la estrategia 1 (sin preview avanzada).
 Con PyCUDA se procesa en el mismo POST /posts.
Request (conceptual)
POST /posts
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

Partes del form:
â—	image: archivo (la foto).

â—	filter: string (ej.: "ups_logo").

â—	description: string (opcional).

Conceptual en JSON:
{
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜"
  // + archivo 'image'
}

________________________________________
Response (201 Created)
{
  "id": "postId123",
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": null,
  "imageUrl": "https://firebasestorage.googleapis.com/ups/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 0,
  "commentsCount": 0,
  "likedByMe": true
}

________________________________________
3.4. GET /posts/{postId} â€“ detalle de un post
Request
GET /posts/postId123
Authorization: Bearer <idToken>   // opcional

Response (200 OK)
{
  "id": "postId123",
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": null,
  "imageUrl": "https://firebasestorage.googleapis.com/ups/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 5,
  "commentsCount": 2,
  "likedByMe": true
}

________________________________________
3.5. DELETE /posts/{postId} â€“ borrar un post
Usado cuando el dueÃ±o de la publicaciÃ³n la quiere eliminar.
Request
DELETE /posts/postId123
Authorization: Bearer <idToken>

Response
OpciÃ³n simple:
204 No Content

O bien:
{ "message": "Post eliminado correctamente" }

________________________________________
4. IMÃGENES + PREVIEW CON PyCUDA (ESTRATEGIA 2 â€“ AVANZADA)
4.1. POST /images/preview â€“ aplicar filtro y obtener imagen filtrada (preview)
Se usa justo despuÃ©s de tomar la foto, antes de mostrar la pantalla de â€œcrear postâ€.
Request
POST /images/preview
Authorization: Bearer <idToken>
Content-Type: multipart/form-data

Partes del form:
â—	image: archivo (foto original tomada por la cÃ¡mara).

â—	filter: string con el nombre del filtro elegido:

â—‹	"ups_logo"

â—‹	"gaussian"

â—‹	"sharpen"

â—‹	"edge_detect"

Conceptual:
{
  "filter": "ups_logo"
  // + archivo 'image'
}

Flujo interno
1.	Valida el token â†’ userId.

Llama al PyCUDA Service:

 POST http://pycuda-service:5000/filters/{filter}
Content-Type: image/jpeg
Body: [bytes de la imagen]
2.	
3.	PyCUDA devuelve la imagen filtrada (bytes).

4.	El backend sube esa imagen filtrada a Firebase Storage en una carpeta temporal:

â—‹	temp/tmp-12345.jpg

5.	Genera tempImageId = "tmp-12345".

________________________________________
Response (200 OK)
{
  "tempImageId": "tmp-12345",
  "imageUrl": "https://firebasestorage.googleapis.com/v0/b/tu-bucket/o/temp%2Ftmp-12345.jpg?alt=media"
}

Campos:
â—	tempImageId: ID que luego se usarÃ¡ en POST /posts.

â—	imageUrl: URL de la imagen filtrada temporal, para mostrarla como preview.

________________________________________
Errores tÃ­picos
â—	400 BAD_REQUEST

â—‹	Faltan partes (image o filter), formato no vÃ¡lido, etc.

â—	401 UNAUTHORIZED

â—‹	Token ausente o invÃ¡lido.

â—	500 INTERNAL_SERVER_ERROR

â—‹	Falla PyCUDA o Storage.

________________________________________
4.2. POST /posts â€“ crear publicaciÃ³n usando tempImageId (variante con preview)
Estrategia 2: aquÃ­ POST /posts ya NO recibe archivo, solo el tempImageId.
Request
POST /posts
Authorization: Bearer <idToken>
Content-Type: application/json

Body:
{
  "tempImageId": "tmp-12345",
  "description": "Foto en la UPS ğŸ˜",
  "filter": "ups_logo"
}

Campos:
â—	tempImageId: ID devuelto por /images/preview.

â—	description: texto de la publicaciÃ³n.

â—	filter: nombre del filtro aplicado (se guarda en Firestore).

________________________________________
Flujo interno
1.	Valida token â†’ userId.

2.	Localiza la imagen temporal en Storage:

â—‹	De: temp/tmp-12345.jpg

3.	Genera postId (id de documento en Firestore).

4.	Mueve/renombra la imagen a carpeta definitiva:

â—‹	A: posts/postId123.jpg

Construye URL final:

 https://firebasestorage.googleapis.com/.../posts/postId123.jpg
5.	
Crea documento en posts:

 {
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": null,
  "imageUrl": "https://.../posts/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 0,
  "commentsCount": 0
}
6.	
7.	(Opcional) Borra temp/tmp-12345.jpg.

8.	Devuelve el Post creado.

________________________________________
Response (201 Created)
{
  "id": "postId123",
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": null,
  "imageUrl": "https://firebasestorage.googleapis.com/ups/posts/postId123.jpg",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "2025-12-03T10:00:00Z",
  "likesCount": 0,
  "commentsCount": 0,
  "likedByMe": true
}

________________________________________
Errores
â—	400 BAD_REQUEST

â—‹	Falta tempImageId, no existe, etc.

â—	401 UNAUTHORIZED

â—	404 NOT_FOUND

â—‹	La imagen temporal tempImageId no existe (expirada o borrada).

â—	500 INTERNAL_SERVER_ERROR

â—‹	Fallo al mover imagen o guardar post.


5. LIKES ğŸ‘
5.1. Modelo de like (interno / Firestore)
En Firestore puedes guardar algo asÃ­:
â—	ColecciÃ³n: posts/{postId}/likes/{userId}
 Documento:

{
  "userId": "uid123",
  "createdAt": "2025-12-03T10:05:00Z"
}

En las respuestas de la API no devolvemos el like individual, sino:
â—	likesCount (en el Post)

â—	likedByMe (en el Post y en las respuestas de like/unlike)

________________________________________
5.2. POST /posts/{postId}/likes â€“ dar like
Se llama cuando el usuario toca el corazÃ³n vacÃ­o.
Request
POST /posts/{postId}/likes
Authorization: Bearer <idToken>

Body: vacÃ­o.
________________________________________
Flujo interno (backend)
1.	Valida token â†’ obtiene userId.

2.	Crea (o asegura) documento en Firestore:

â—‹	posts/{postId}/likes/{userId}.

3.	Incrementa likesCount del post (o lo recalcula).

4.	Opcionalmente guarda info para saber si el usuario ya hizo like (para cÃ¡lculo de likedByMe).

5.	Devuelve estado actualizado.

________________________________________
Response (200 OK)
{
  "postId": "postId123",
  "likesCount": 6,
  "likedByMe": true
}

La app usa esto para:
â—	Cambiar el icono a corazÃ³n lleno.

â—	Actualizar el nÃºmero de likes.

________________________________________
Errores tÃ­picos
â—	401 UNAUTHORIZED
 Sin token / token invÃ¡lido.

â—	404 NOT_FOUND
 El post no existe.

________________________________________
5.3. DELETE /posts/{postId}/likes â€“ quitar like
Se llama cuando el usuario toca el corazÃ³n lleno para des-likear.
Request
DELETE /posts/{postId}/likes
Authorization: Bearer <idToken>

Body: vacÃ­o.
________________________________________
Flujo interno
1.	Valida token â†’ userId.

2.	Borra doc posts/{postId}/likes/{userId} si existe.

3.	Decrementa likesCount (o recalcula).

4.	Devuelve estado actualizado.

________________________________________
Response (200 OK)
{
  "postId": "postId123",
  "likesCount": 5,
  "likedByMe": false
}

La app:
â—	Pone el corazÃ³n en gris.

â—	Actualiza el nÃºmero.

________________________________________
Errores tÃ­picos
â—	401 UNAUTHORIZED

â—	404 NOT_FOUND (post inexistente).

________________________________________
5.4. GET /posts/{postId}/likes â€“ listar quiÃ©nes dieron like (opcional)
Solo si quieres una pantalla tipo â€œA X personas les gusta estoâ€.
Request
GET /posts/{postId}/likes?page=0&size=20
Authorization: Bearer <idToken>

________________________________________
Response (200 OK)
{
  "page": 0,
  "size": 20,
  "totalItems": 2,
  "items": [
    {
      "userId": "uid123",
      "username": "pepito",
      "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/uid123.jpg"
    },
    {
      "userId": "uid999",
      "username": "maria",
      "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/maria.jpg"
    }
  ]
}

________________________________________
6. COMMENTS ğŸ’¬
6.1. Modelo Comment
Este es el formato estÃ¡ndar de un comentario:
{
  "id": "commentId456",
  "postId": "postId123",
  "userId": "uid999",
  "username": "maria",
  "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/maria.jpg",
  "text": "QuÃ© buena foto ğŸ˜",
  "createdAt": "2025-12-03T10:05:00Z"
}

En Firestore:
â—	posts/{postId}/comments/{commentId} con esos campos.

________________________________________
6.2. GET /posts/{postId}/comments â€“ listar comentarios
Usado cuando en la app tocas el icono ğŸ’¬ y se abre el panel desde abajo (tipo Instagram).
 El backend no sabe del â€œpanelâ€, solo devuelve la lista.
Request
GET /posts/{postId}/comments?page=0&size=20
Authorization: Bearer <idToken>   // puedes permitirlo sin token si quieres

Query params:
â—	page: pÃ¡gina (0 por defecto).

â—	size: cuÃ¡ntos comentarios.

________________________________________
Response (200 OK)
{
  "page": 0,
  "size": 20,
  "totalItems": 2,
  "items": [
    {
      "id": "commentId456",
      "postId": "postId123",
      "userId": "uid999",
      "username": "maria",
      "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/maria.jpg",
      "text": "QuÃ© buena foto ğŸ˜",
      "createdAt": "2025-12-03T10:05:00Z"
    },
    {
      "id": "commentId457",
      "postId": "postId123",
      "userId": "uid123",
      "username": "pepito",
      "userPhotoUrl": null,
      "text": "Gracias! ğŸ˜",
      "createdAt": "2025-12-03T10:06:00Z"
    }
  ]
}

La app simplemente muestra items[] en esa mini pantalla.
________________________________________
6.3. POST /posts/{postId}/comments â€“ crear comentario
Cuando el usuario escribe un comentario en el panel y toca â€œEnviarâ€.
Request
POST /posts/{postId}/comments
Authorization: Bearer <idToken>
Content-Type: application/json

Body:
{
  "text": "QuÃ© buena foto ğŸ˜"
}

________________________________________
Flujo interno
1.	Valida token â†’ userId, username, userPhotoUrl.

2.	Crea doc posts/{postId}/comments/{commentId} en Firestore.

3.	Incrementa commentsCount del post.

4.	Devuelve el comentario creado.

________________________________________
Response (201 Created)
{
  "id": "commentId456",
  "postId": "postId123",
  "userId": "uid999",
  "username": "maria",
  "userPhotoUrl": "https://firebasestorage.googleapis.com/avatars/maria.jpg",
  "text": "QuÃ© buena foto ğŸ˜",
  "createdAt": "2025-12-03T10:05:00Z"
}

La app puede:
â—	Insertar este comentario al final de la lista del panel.

â—	Incrementar commentsCount del post en el feed.

________________________________________
Errores tÃ­picos
400 BAD_REQUEST
 text vacÃ­o o demasiado largo.

 { "code": "VALIDATION_ERROR", "message": "El comentario no puede estar vacÃ­o" }
â—	
â—	401 UNAUTHORIZED

â—	404 NOT_FOUND (postId inexistente).

________________________________________
6.4. DELETE /posts/{postId}/comments/{commentId} â€“ borrar comentario (opcional)
Solo si quieres permitir que el autor borre su propio comentario (o el dueÃ±o del post).
Request
DELETE /posts/{postId}/comments/{commentId}
Authorization: Bearer <idToken>

Response
204 No Content

(Internamente puedes decrementar commentsCount del post.)
________________________________________
6.5. (Opcional PRO) GET /posts/{postId}/comments/stream
Si quieres hacer tiempo real en serio con WebFlux, puedes exponerse como SSE:
â—	GET /posts/{postId}/comments/stream

â—	produces: text/event-stream

â—	Respuesta: Flux<Comment>

Pero esto ya es extra para lucirte, no obligatorio.




























7. Vista general de la arquitectura
A alto nivel:
[ App mÃ³vil ]
      â”‚  (HTTP/JSON)
      â–¼
[ API Gateway (WebFlux) ]
      â”‚
      â”œâ”€â”€â–º [ Auth/User Service (WebFlux + Firebase Auth/Firestore) ]
      â”‚
      â””â”€â”€â–º [ Post Service (WebFlux + Firestore + Storage) ]
                 â”‚
                 â””â”€â”€â–º [ PyCUDA Service (Python + CUDA) ]

[ Firebase Auth ]      [ Firestore ]      [ Firebase Storage ]
        â–²                    â–²                    â–²
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ usados desde Auth/User y Post Service â”€â”€â”˜

Todo lo que documentaste de API (los endpoints) lo ve la app como si fuera un solo backend, pero por dentro estÃ¡ distribuido.


1. API Gateway (Spring Cloud Gateway + WebFlux)
Rol principal: â€œpuerta de entrada Ãºnicaâ€.
â—	Puerto pÃºblico: :8080

â—	La app mÃ³vil SIEMPRE habla con http://gateway:8080.

Responsabilidades
â—	Enrutar peticiones:

â—‹	/auth/** y /users/** â†’ auth-user-service

â—‹	/feed, /posts/**, /images/** â†’ post-service

â—	Aplicar cross-cutting:

â—‹	CORS, logging, rate limit (si quieres).

â—‹	Opcional: validaciÃ³n de token JWT de Firebase:

â– 	Verifica Authorization: Bearer <idToken>.

â– 	Extrae uid.

â– 	Inyecta cabeceras como X-User-Id, X-User-Email para los servicios internos.

â—	No tiene lÃ³gica de dominio (no sabe quÃ© es un post, ni un filtro, ni likes).

Principios que cumple
â—	Single Responsibility: solo gateway, no mezcla negocio.

â—	Separation of Concerns: seguridad y routing desacoplados de negocio.

â—	Backend for Frontend (BFF)-like: un solo endpoint para la app mÃ³vil.

________________________________________
2. Auth & User Service (WebFlux + Firebase Auth + Firestore)
Este servicio implementa todo lo relacionado con usuarios:
2.1. Endpoints pÃºblicos (tras el gateway)
â—	POST /auth/register

â—	POST /auth/login

â—	GET /auth/me

â—	PATCH /users/me

â—	PUT /users/me/avatar

â—	GET /users/{userId}

2.2. Responsabilidades
â—	Registrar usuarios en Firebase Auth.

â—	Verificar credenciales en login (Firebase Auth + Firestore para username).

â—	Gestionar el perfil en colecciÃ³n users/{uid} de Firestore:

â—‹	username, fullName, photoUrl, bio, etc.

â—	Gestionar la imagen de avatar en Firebase Storage:

â—‹	avatars/{uid}.jpg.

2.3. Internamente (capas sugeridas)
Arquitectura tÃ­pica en capas (estilo hexagonal / clean):
â—	Controller/Handler WebFlux

â—‹	Mapea requests a handlers reactivos:

â—‹	Devuelven Mono<UserResponse> o similar.

â—	Service (dominio de auth/usuario)

â—‹	LÃ³gica de negocio:

â– 	Validar reglas de username, email, etc.

â– 	Coordinar Firebase Auth + Firestore.

â—	Ports & Adapters (infra)

â—‹	FirebaseAuthClient (adaptador al SDK de Firebase Auth).

â—‹	UserRepository (Firestore).

â—‹	StorageClient (Firebase Storage para avatar).

â—	Modelos:

â—‹	User (dominio).

â—‹	UserDocument (Firestore).

â—‹	UserResponse (DTO de salida).

Principios de diseÃ±o aplicados
â—	SRP: este servicio solo se encarga de usuarios/autenticaciÃ³n.

â—	Bounded Context: â€œUser Managementâ€ estÃ¡ aislado.

â—	Ports & Adapters: Firebase es un detalle, reemplazable.

â—	ProgramaciÃ³n reactiva: usar Mono.fromFuture(...) para integrar Firebase async con WebFlux.

________________________________________
3. Post Service (WebFlux + Firestore + Storage + PyCUDA)
Este es tu servicio â€œgordoâ€ de dominio de la app social: posts, feed, likes, comentarios, filtros.
3.1. Endpoints pÃºblicos (tras el gateway)
â—	Feed & posts:

â—‹	GET /feed

â—‹	POST /posts (versiÃ³n simple multipart)

â—‹	POST /posts (versiÃ³n JSON con tempImageId)

â—‹	GET /posts/{postId}

â—‹	DELETE /posts/{postId}

â—	ImÃ¡genes / CUDA:

â—‹	POST /images/preview

â—	Likes:

â—‹	POST /posts/{postId}/likes

â—‹	DELETE /posts/{postId}/likes

â—‹	GET /posts/{postId}/likes (opcional)

â—	Comments:

â—‹	GET /posts/{postId}/comments

â—‹	POST /posts/{postId}/comments

â—‹	DELETE /posts/{postId}/comments/{commentId} (opcional)

â—‹	GET /posts/{postId}/comments/stream (super pro, opcional)

3.2. Responsabilidades principales
â—	GestiÃ³n de posts:

â—‹	Crear posts con imagen + filtro.

â—‹	Obtener feed paginado (GET /feed).

â—‹	Obtener detalle de post.

â—‹	Eliminar post (dueÃ±o).

â—	IntegraciÃ³n con PyCUDA:

â—‹	POST /images/preview â†’ llama a pycuda-service.

â—‹	Variante 1: procesa dentro de POST /posts.

â—‹	Variante 2: preview con tempImageId y luego crear post.

â—	Persistencia de posts en Firestore:

â—‹	ColecciÃ³n posts/{postId}.

â—‹	Campos: userId, imageUrl, filter, description, createdAt, likesCount, commentsCount, etc.

â—	Likes:

â—‹	ColecciÃ³n posts/{postId}/likes/{userId} en Firestore.

â—‹	Mantener likesCount y likedByMe.

â—	Comentarios:

â—‹	ColecciÃ³n posts/{postId}/comments/{commentId}.

â—‹	Mantener commentsCount.

â—	ImÃ¡genes:

â—‹	Subir/borrar/mover imÃ¡genes en Firebase Storage:

â– 	temp/{tempImageId}.jpg

â– 	posts/{postId}.jpg

3.3. Capas internas (diseÃ±o)
SÃºper recomendable dividir internamente en subdominios:
a) MÃ³dulo post (dominio de publicaciones)
â—	PostController / PostHandler (WebFlux):

â—‹	/feed

â—‹	/posts

â—‹	/posts/{postId}

â—	PostService:

â—‹	Crear post desde imagen directa (estrategia 1).

â—‹	Crear post desde tempImageId (estrategia 2).

â—‹	Listar feed.

â—‹	Obtener detalle.

â—‹	Borrar post.

â—	PostRepository (Firestore):

â—‹	savePost(Post)

â—‹	findById(postId)

â—‹	findFeed(page, size)

b) MÃ³dulo media (imÃ¡genes + CUDA)
â—	ImageController / ImageHandler:

â—‹	POST /images/preview

â—	ImageService:

â—‹	Encargado de:

â– 	Enviar imagen a pycuda-service.

â– 	Recibir imagen filtrada.

â– 	Guardar en Storage como temp/{tempImageId}.jpg.

â– 	Mover de temp/ a posts/.

â—‹	No sabe nada de likes ni de comments â†’ solo media.

â—	PyCudaClient (adaptador HTTP reactivo usando WebClient):

â—‹	applyFilter(filterName, imageBytes): Mono<byte[]>

â—	StorageClient (Firebase Storage):

â—‹	uploadTemp(imageBytes) -> tempImageId + imageUrl

â—‹	moveTempToPost(tempImageId, postId) -> imageUrlFinal

c) MÃ³dulo likes
â—	LikeController:

â—‹	POST /posts/{postId}/likes

â—‹	DELETE /posts/{postId}/likes

â—‹	GET /posts/{postId}/likes (opcional)

â—	LikeService:

â—‹	Agregar/quitar like.

â—‹	Calcular/actualizar likesCount.

â—‹	Saber likedByMe.

â—	LikeRepository (Firestore):

â—‹	ColecciÃ³n posts/{postId}/likes.

d) MÃ³dulo comments
â—	CommentController:

â—‹	GET /posts/{postId}/comments

â—‹	POST /posts/{postId}/comments

â—‹	DELETE /posts/{postId}/comments/{commentId}

â—	CommentService:

â—‹	Listar comentarios paginados.

â—‹	Crear comentario.

â—‹	Borrar comentario.

â—‹	Incrementar/decrementar commentsCount.

â—	CommentRepository (Firestore):

â—‹	ColecciÃ³n posts/{postId}/comments.

3.4. Principios de diseÃ±o aplicados
â—	Single Responsibility:

â—‹	Media no mezcla likes.

â—‹	Comments no mezcla PyCUDA.

â—‹	PostService orquesta pero no sube archivos directamente (usa ImageService).

â—	Separation of Concerns:

â—‹	Controladores HTTP vs servicios de dominio vs adaptadores a Firebase/PyCUDA.

â—	Hexagonal / Ports & Adapters:

â—‹	PostService + LikeService + CommentService representan el dominio.

â—‹	Firestore, Storage, PyCUDA son adaptadores externos.

â—	ProgramaciÃ³n reactiva:

â—‹	Usar Flux/Mono en controladores:

â– 	Flux<PostResponse> para feed.

â– 	Flux<CommentResponse> para comentarios.

â—‹	ComunicaciÃ³n HTTP entre servicios: WebClient (no RestTemplate).

________________________________________
4. PyCUDA Service (Python + Flask/FastAPI)
Este es tu microservicio especializado en GPU.
Endpoints internos (no pÃºblicos a la app)
â—	POST /filters/{filterName}
 Content-Type: image/jpeg
 Body: bytes de imagen.
 Respuesta: bytes de imagen filtrada (image/jpeg).

Responsabilidades
â—	Cargar kernels CUDA (en GPU).

â—	Aplicar filtros de convoluciÃ³n:

â—‹	gaussian, sharpen, edge_detect, ups_logo, etc.

â—	No sabe nada de usuarios, posts, Firebaseâ€¦ solo imÃ¡genes.

Principios
â—	SRP extremo: solo hace procesamiento de imagen.

â—	High Cohesion, Low Coupling: interfaz mÃ­nima (HTTP binario).

________________________________________
5. Firebase como plataforma de datos
5.1. Firebase Auth
â—	Usado por Auth/User Service:

â—‹	Registro de credenciales.

â—‹	Login / verificaciÃ³n de password.

â—	Opcionalmente por el Gateway (para verificar idToken y extraer uid).

5.2. Firestore
Colecciones sugeridas:
users/{uid}

 {
  "email": "user@ups.edu.ec",
  "username": "pepito",
  "fullName": "Pepito PÃ©rez",
  "photoUrl": "...",
  "bio": "..."
}
â—	
posts/{postId}

 {
  "userId": "uid123",
  "username": "pepito",
  "userPhotoUrl": "...",
  "imageUrl": "...",
  "filter": "ups_logo",
  "description": "Foto en la UPS ğŸ˜",
  "createdAt": "...",
  "likesCount": 5,
  "commentsCount": 2
}
â—	
posts/{postId}/likes/{userId}

 {
  "userId": "uid123",
  "createdAt": "..."
}
â—	
posts/{postId}/comments/{commentId}

 {
  "postId": "postId123",
  "userId": "uid999",
  "username": "maria",
  "userPhotoUrl": "...",
  "text": "QuÃ© buena foto ğŸ˜",
  "createdAt": "..."
}
â—	
5.3. Firebase Storage
â—	Avatares:

â—‹	avatars/{uid}.jpg

â—	ImÃ¡genes temporales:

â—‹	temp/{tempImageId}.jpg

â—	ImÃ¡genes finales de posts:

â—‹	posts/{postId}.jpg


ğŸ—‚ Estructura general del repo
upsglam-backend/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â”œâ”€â”€ api-gateway/
â”œâ”€â”€ auth-user-service/
â”œâ”€â”€ post-service/
â””â”€â”€ pycuda-service/

________________________________________
1ï¸âƒ£ api-gateway (Spring Cloud Gateway)
AquÃ­ casi no hay dominio, es solo configuraciÃ³n + filtros.
api-gateway/
â”œâ”€â”€ pom.xml
â””â”€â”€ src/
    â””â”€â”€ main/
        â”œâ”€â”€ java/
        â”‚   â””â”€â”€ ec/ups/upsglam/gateway/
        â”‚       â”œâ”€â”€ GatewayApplication.java
        â”‚       â”œâ”€â”€ config/
        â”‚       â”‚   â”œâ”€â”€ GatewayRoutesConfig.java      # si configuras rutas via Java
        â”‚       â”‚   â””â”€â”€ SecurityConfig.java           # filtro de auth global (opcional)
        â”‚       â””â”€â”€ security/
        â”‚           â””â”€â”€ FirebaseAuthenticationFilter.java  # valida idToken, mete X-User-Id
        â””â”€â”€ resources/
            â”œâ”€â”€ application.yml                       # rutas, puertos, etc.
            â””â”€â”€ bootstrap.yml                         # si usas profiles

â—	Principio: este mÃ³dulo casi no tiene â€œlÃ³gicaâ€, solo configuraciÃ³n de gateway + seguridad.

________________________________________
2ï¸âƒ£ auth-user-service (usuarios + auth + perfil)
Java, WebFlux, integraciÃ³n con Firebase Auth + Firestore + Storage.
auth-user-service/
â”œâ”€â”€ pom.xml
â””â”€â”€ src/
    â””â”€â”€ main/
        â”œâ”€â”€ java/
        â”‚   â””â”€â”€ ec/ups/upsglam/auth/
        â”‚       â”œâ”€â”€ AuthUserServiceApplication.java
        â”‚       â”œâ”€â”€ config/
        â”‚       â”‚   â”œâ”€â”€ WebFluxConfig.java           # CORS, codecs, etc.
        â”‚       â”‚   â””â”€â”€ FirebaseConfig.java          # beans de FirebaseApp, Firestore, Storage
        â”‚       â”œâ”€â”€ api/                             # capa de exposiciÃ³n HTTP
        â”‚       â”‚   â”œâ”€â”€ router/
        â”‚       â”‚   â”‚   â””â”€â”€ AuthUserRouter.java      # define rutas funcionales
        â”‚       â”‚   â””â”€â”€ handler/
        â”‚       â”‚       â”œâ”€â”€ AuthHandler.java         # /auth/register, /auth/login
        â”‚       â”‚       â””â”€â”€ UserHandler.java         # /auth/me, /users/me, /users/{id}
        â”‚       â”œâ”€â”€ domain/                          # modelos y servicios de dominio
        â”‚       â”‚   â”œâ”€â”€ model/
        â”‚       â”‚   â”‚   â””â”€â”€ User.java
        â”‚       â”‚   â”œâ”€â”€ service/
        â”‚       â”‚   â”‚   â”œâ”€â”€ AuthService.java         # lÃ³gica de registro/login
        â”‚       â”‚   â”‚   â””â”€â”€ UserProfileService.java  # lÃ³gica de perfil, bio, avatar
        â”‚       â”‚   â””â”€â”€ exception/
        â”‚       â”‚       â”œâ”€â”€ UserNotFoundException.java
        â”‚       â”‚       â””â”€â”€ GlobalErrorHandler.java  # traduce excepciones a JSON de error
        â”‚       â””â”€â”€ infrastructure/                  # adapters a Firebase / persistence
        â”‚           â”œâ”€â”€ firebase/
        â”‚           â”‚   â”œâ”€â”€ FirebaseAuthClient.java  # wrapper reactivo sobre Firebase Auth
        â”‚           â”‚   â”œâ”€â”€ FirestoreUserRepository.java # CRUD users/{uid}
        â”‚           â”‚   â””â”€â”€ FirebaseStorageClient.java    # avatars/{uid}.jpg
        â”‚           â””â”€â”€ mapper/
        â”‚               â””â”€â”€ UserMapper.java          # User <-> DTO (UserResponse)
        â””â”€â”€ resources/
            â””â”€â”€ application.yml

â—	api/* â†’ solo HTTP (request/response).

â—	domain/* â†’ reglas de negocio, modelos.

â—	infrastructure/* â†’ Firebase, DB, Storage, mapeos.

________________________________________
3ï¸âƒ£ post-service (posts, feed, likes, comments, PyCUDA, media)
Este va mÃ¡s cargadito, pero lo organizamos por subdominios: post, media, like, comment.
post-service/
â”œâ”€â”€ pom.xml
â””â”€â”€ src/
    â””â”€â”€ main/
        â”œâ”€â”€ java/
        â”‚   â””â”€â”€ ec/ups/upsglam/post/
        â”‚       â”œâ”€â”€ PostServiceApplication.java
        â”‚       â”œâ”€â”€ config/
        â”‚       â”‚   â”œâ”€â”€ WebFluxConfig.java
        â”‚       â”‚   â”œâ”€â”€ FirebaseConfig.java          # Firestore + Storage
        â”‚       â”‚   â””â”€â”€ PyCudaClientConfig.java      # WebClient para pycuda-service
        â”‚       â”œâ”€â”€ api/
        â”‚       â”‚   â”œâ”€â”€ router/
        â”‚       â”‚   â”‚   â”œâ”€â”€ PostRouter.java          # /feed, /posts...
        â”‚       â”‚   â”‚   â”œâ”€â”€ MediaRouter.java         # /images/preview
        â”‚       â”‚   â”‚   â”œâ”€â”€ LikeRouter.java          # /posts/{id}/likes
        â”‚       â”‚   â”‚   â””â”€â”€ CommentRouter.java       # /posts/{id}/comments
        â”‚       â”‚   â””â”€â”€ handler/
        â”‚       â”‚       â”œâ”€â”€ PostHandler.java
        â”‚       â”‚       â”œâ”€â”€ MediaHandler.java
        â”‚       â”‚       â”œâ”€â”€ LikeHandler.java
        â”‚       â”‚       â””â”€â”€ CommentHandler.java
        â”‚       â”œâ”€â”€ domain/
        â”‚       â”‚   â”œâ”€â”€ post/
        â”‚       â”‚   â”‚   â”œâ”€â”€ model/
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Post.java            # modelo de dominio Post
        â”‚       â”‚   â”‚   â”œâ”€â”€ service/
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ PostService.java     # feed, crear/borrar post, detalle
        â”‚       â”‚   â”‚   â””â”€â”€ dto/
        â”‚       â”‚   â”‚       â”œâ”€â”€ PostRequest.java     # body de creaciÃ³n (multipart/JSON)
        â”‚       â”‚   â”‚       â””â”€â”€ PostResponse.java    # modelo que ya definiste con likedByMe
        â”‚       â”‚   â”œâ”€â”€ media/
        â”‚       â”‚   â”‚   â”œâ”€â”€ service/
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ ImageService.java    # coordina CUDA + Storage (temp/posts)
        â”‚       â”‚   â”‚   â””â”€â”€ model/
        â”‚       â”‚   â”‚       â””â”€â”€ TempImage.java       # tempImageId, imageUrl
        â”‚       â”‚   â”œâ”€â”€ like/
        â”‚       â”‚   â”‚   â”œâ”€â”€ model/
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Like.java
        â”‚       â”‚   â”‚   â””â”€â”€ service/
        â”‚       â”‚   â”‚       â””â”€â”€ LikeService.java     # add/remove, obtener likesCount, likedByMe
        â”‚       â”‚   â”œâ”€â”€ comment/
        â”‚       â”‚   â”‚   â”œâ”€â”€ model/
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Comment.java
        â”‚       â”‚   â”‚   â”œâ”€â”€ dto/
        â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ CommentRequest.java
        â”‚       â”‚   â”‚   â”‚   â””â”€â”€ CommentResponse.java
        â”‚       â”‚   â”‚   â””â”€â”€ service/
        â”‚       â”‚   â”‚       â””â”€â”€ CommentService.java
        â”‚       â”‚   â””â”€â”€ exception/
        â”‚       â”‚       â”œâ”€â”€ PostNotFoundException.java
        â”‚       â”‚       â”œâ”€â”€ TempImageNotFoundException.java
        â”‚       â”‚       â””â”€â”€ GlobalErrorHandler.java
        â”‚       â””â”€â”€ infrastructure/
        â”‚           â”œâ”€â”€ firestore/
        â”‚           â”‚   â”œâ”€â”€ PostRepository.java          # Firestore para posts
        â”‚           â”‚   â”œâ”€â”€ LikeRepository.java          # posts/{id}/likes
        â”‚           â”‚   â””â”€â”€ CommentRepository.java       # posts/{id}/comments
        â”‚           â”œâ”€â”€ storage/
        â”‚           â”‚   â””â”€â”€ FirebasePostStorageClient.java
        â”‚           â”‚       # uploadTemp(...), moveTempToPost(...)
        â”‚           â”œâ”€â”€ pycuda/
        â”‚           â”‚   â””â”€â”€ PyCudaClient.java            # WebClient -> /filters/{filter}
        â”‚           â””â”€â”€ mapper/
        â”‚               â”œâ”€â”€ PostMapper.java
        â”‚               â””â”€â”€ CommentMapper.java
        â””â”€â”€ resources/
            â””â”€â”€ application.yml

QuÃ© ganas con esta estructura
â—	Sabes que TODO lo referente a post estÃ¡ en domain/post y api/router/handler.

â—	Todo lo de CUDA + imÃ¡genes estÃ¡ concentrado en domain/media + infrastructure/storage + pycuda.

â—	Likes y comments no contaminan el cÃ³digo de media.

________________________________________
4ï¸âƒ£ pycuda-service (Python + CUDA)
AquÃ­ sÃ­ usas la tÃ­pica app.py o main.py, pero bien ordenadito.
pycuda-service/
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ Dockerfile
â””â”€â”€ src/
    â”œâ”€â”€ app.py                         # punto de entrada Flask/FastAPI
    â”œâ”€â”€ api/
    â”‚   â””â”€â”€ filters_controller.py      # endpoint /filters/{filterName}
    â”œâ”€â”€ core/
    â”‚   â”œâ”€â”€ cuda_context.py            # inicializaciÃ³n de contexto CUDA
    â”‚   â”œâ”€â”€ kernels/
    â”‚   â”‚   â”œâ”€â”€ gaussian.cu
    â”‚   â”‚   â”œâ”€â”€ sharpen.cu
    â”‚   â”‚   â”œâ”€â”€ edge_detect.cu
    â”‚   â”‚   â””â”€â”€ ups_logo.cu
    â”‚   â””â”€â”€ filter_service.py          # aplica filtros usando PyCUDA
    â””â”€â”€ utils/
        â”œâ”€â”€ image_io.py                # leer bytes -> np.array, array -> bytes
        â””â”€â”€ config.py

â—	api/filters_controller.py:

â—‹	POST /filters/{filterName} recibe imagen y llama a filter_service.

â—	core/filter_service.py:

â—‹	Selecciona kernel segÃºn filterName, ejecuta en GPU y devuelve bytes.

________________________________________
5ï¸âƒ£ RaÃ­z del repo + Docker Compose
Para que toda la arquitectura viva feliz en una red Docker:
upsglam-backend/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ api-gateway/
â”œâ”€â”€ auth-user-service/
â”œâ”€â”€ post-service/
â””â”€â”€ pycuda-service/

Ejemplo muy resumido de docker-compose.yml:
services:
  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    depends_on:
      - auth-user-service
      - post-service

  auth-user-service:
    build: ./auth-user-service
    depends_on:
      - firebase-emulator # si lo usas local

  post-service:
    build: ./post-service
    depends_on:
      - pycuda-service

  pycuda-service:
    build: ./pycuda-service
    # aquÃ­ montas GPU si tienes

  # opcional: firebase emulator para local
  firebase-emulator:
    image: somedev/firebase-emulator



ESQUELETO 


ğŸ§© 1. post-service â€“ estructura de paquetes
ec.ups.upsglam.post
â”œâ”€â”€ PostServiceApplication.java
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ WebFluxConfig.java
â”‚   â”œâ”€â”€ FirebaseConfig.java
â”‚   â””â”€â”€ PyCudaClientConfig.java
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â”œâ”€â”€ PostRouter.java
â”‚   â”‚   â”œâ”€â”€ MediaRouter.java
â”‚   â”‚   â”œâ”€â”€ LikeRouter.java
â”‚   â”‚   â””â”€â”€ CommentRouter.java
â”‚   â””â”€â”€ handler/
â”‚       â”œâ”€â”€ PostHandler.java
â”‚       â”œâ”€â”€ MediaHandler.java
â”‚       â”œâ”€â”€ LikeHandler.java
â”‚       â””â”€â”€ CommentHandler.java
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ post/
â”‚   â”‚   â”œâ”€â”€ model/Post.java
â”‚   â”‚   â”œâ”€â”€ dto/PostResponse.java
â”‚   â”‚   â””â”€â”€ service/PostService.java
â”‚   â”œâ”€â”€ media/
â”‚   â”‚   â”œâ”€â”€ model/TempImage.java
â”‚   â”‚   â””â”€â”€ service/ImageService.java
â”‚   â”œâ”€â”€ like/
â”‚   â”‚   â”œâ”€â”€ model/Like.java
â”‚   â”‚   â””â”€â”€ service/LikeService.java
â”‚   â”œâ”€â”€ comment/
â”‚   â”‚   â”œâ”€â”€ model/Comment.java
â”‚   â”‚   â”œâ”€â”€ dto/CommentRequest.java
â”‚   â”‚   â””â”€â”€ service/CommentService.java
â”‚   â””â”€â”€ exception/...
â””â”€â”€ infrastructure/
    â”œâ”€â”€ firestore/
    â”‚   â”œâ”€â”€ PostRepository.java
    â”‚   â”œâ”€â”€ LikeRepository.java
    â”‚   â””â”€â”€ CommentRepository.java
    â”œâ”€â”€ storage/FirebasePostStorageClient.java
    â””â”€â”€ pycuda/PyCudaClient.java

________________________________________
1.1. Router + Handler para POSTS
PostRouter.java
package ec.ups.upsglam.post.api.router;

import ec.ups.upsglam.post.api.handler.PostHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;

import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration
public class PostRouter {

    @Bean
    public RouterFunction<?> postRoutes(PostHandler handler) {
        return route(GET("/feed"), handler::getFeed)
            .andRoute(POST("/posts").and(contentType(org.springframework.http.MediaType.MULTIPART_FORM_DATA)), handler::createPostMultipart)
            .andRoute(POST("/posts").and(contentType(org.springframework.http.MediaType.APPLICATION_JSON)), handler::createPostFromTemp)
            .andRoute(GET("/posts/{postId}"), handler::getPostById)
            .andRoute(DELETE("/posts/{postId}"), handler::deletePost);
    }
}

PostHandler.java (esqueleto)
package ec.ups.upsglam.post.api.handler;

import ec.ups.upsglam.post.domain.post.service.PostService;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

@Component
public class PostHandler {

    private final PostService postService;

    public PostHandler(PostService postService) {
        this.postService = postService;
    }

    public Mono<ServerResponse> getFeed(ServerRequest request) {
        int page = Integer.parseInt(request.queryParam("page").orElse("0"));
        int size = Integer.parseInt(request.queryParam("size").orElse("10"));
        String userId = request.headers().firstHeader("X-User-Id"); // opcional, desde gateway

        return postService.getFeed(page, size, userId)
                .flatMap(feedPage ->
                        ServerResponse.ok()
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(feedPage)
                );
    }

    // Estrategia 1: multipart (image + filter)
    public Mono<ServerResponse> createPostMultipart(ServerRequest request) {
        String userId = request.headers().firstHeader("X-User-Id");
        return postService.createPostFromMultipart(request, userId)
                .flatMap(post ->
                        ServerResponse.status(201)
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(post)
                );
    }

    // Estrategia 2: JSON con tempImageId
    public Mono<ServerResponse> createPostFromTemp(ServerRequest request) {
        String userId = request.headers().firstHeader("X-User-Id");
        return request.bodyToMono(CreatePostFromTempRequest.class)
                .flatMap(body -> postService.createPostFromTemp(body, userId))
                .flatMap(post ->
                        ServerResponse.status(201)
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(post)
                );
    }

    public Mono<ServerResponse> getPostById(ServerRequest request) {
        String postId = request.pathVariable("postId");
        String userId = request.headers().firstHeader("X-User-Id");
        return postService.getPostById(postId, userId)
                .flatMap(post ->
                        ServerResponse.ok()
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(post)
                );
    }

    public Mono<ServerResponse> deletePost(ServerRequest request) {
        String postId = request.pathVariable("postId");
        String userId = request.headers().firstHeader("X-User-Id");
        return postService.deletePost(postId, userId)
                .then(ServerResponse.noContent().build());
    }

    // DTO para estrategia 2
    public static class CreatePostFromTempRequest {
        public String tempImageId;
        public String description;
        public String filter;
    }
}

________________________________________
1.2. Servicio de dominio de POSTS
PostService.java (esqueleto)
package ec.ups.upsglam.post.domain.post.service;

import ec.ups.upsglam.post.api.handler.PostHandler.CreatePostFromTempRequest;
import ec.ups.upsglam.post.domain.media.service.ImageService;
import ec.ups.upsglam.post.domain.post.dto.PostResponse;
import ec.ups.upsglam.post.infrastructure.firestore.PostRepository;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.server.ServerRequest;
import reactor.core.publisher.Mono;

@Service
public class PostService {

    private final PostRepository postRepository;
    private final ImageService imageService;

    public PostService(PostRepository postRepository, ImageService imageService) {
        this.postRepository = postRepository;
        this.imageService = imageService;
    }

    public Mono<FeedPage<PostResponse>> getFeed(int page, int size, String currentUserId) {
        return postRepository.findFeed(page, size, currentUserId);
    }

    public Mono<PostResponse> getPostById(String postId, String currentUserId) {
        return postRepository.findById(postId, currentUserId);
    }

    // Estrategia 1: Multipart (ServerRequest porque viene multipart/form-data)
    public Mono<PostResponse> createPostFromMultipart(ServerRequest request, String userId) {
        // 1) extraer image + filter + description del multipart
        // 2) imageService.processAndUpload(image, filter) -> imageUrl
        // 3) crear documento Post en Firestore -> PostResponse
        return imageService.processAndUploadMultipart(request, userId)
                .flatMap(imageResult ->
                        postRepository.saveNewPost(
                                userId,
                                imageResult.getImageUrl(),
                                imageResult.getFilter(),
                                imageResult.getDescription()
                        )
                );
    }

    // Estrategia 2: JSON con tempImageId
    public Mono<PostResponse> createPostFromTemp(CreatePostFromTempRequest body, String userId) {
        return imageService.moveTempToPost(body.tempImageId)
                .flatMap(imageUrl ->
                        postRepository.saveNewPost(
                                userId,
                                imageUrl,
                                body.filter,
                                body.description
                        )
                );
    }

    public Mono<Void> deletePost(String postId, String userId) {
        // verificar dueÃ±o, borrar post, borrar imagen si quieres
        return postRepository.deletePost(postId, userId);
    }
}

FeedPage<PostResponse> serÃ­a un DTO con page, size, totalItems, items.
________________________________________
1.3. Servicio de imÃ¡genes + PyCUDA
ImageService.java (esqueleto)
package ec.ups.upsglam.post.domain.media.service;

import ec.ups.upsglam.post.domain.media.model.TempImage;
import ec.ups.upsglam.post.infrastructure.pycuda.PyCudaClient;
import ec.ups.upsglam.post.infrastructure.storage.FirebasePostStorageClient;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.server.ServerRequest;
import reactor.core.publisher.Mono;

@Service
public class ImageService {

    private final PyCudaClient pyCudaClient;
    private final FirebasePostStorageClient storageClient;

    public ImageService(PyCudaClient pyCudaClient,
                        FirebasePostStorageClient storageClient) {
        this.pyCudaClient = pyCudaClient;
        this.storageClient = storageClient;
    }

    // Usado en POST /images/preview
    public Mono<TempImage> createPreview(FilePart imagePart, String filter) {
        return imagePart.content()
                .aggregate()
                .asByteArray()
                .flatMap(bytes -> pyCudaClient.applyFilter(filter, bytes))
                .flatMap(filteredBytes -> storageClient.uploadTemp(filteredBytes))
                // uploadTemp devuelve TempImage (tempImageId, imageUrl)
                ;
    }

    // Estrategia 1: procesar y subir en un solo paso al crear post (multipart)
    public Mono<ImageResult> processAndUploadMultipart(ServerRequest request, String userId) {
        // leer partes: image, filter, description
        return request.multipartData()
                .flatMap(parts -> {
                    FilePart imagePart = (FilePart) parts.toSingleValueMap().get("image");
                    String filter = parts.toSingleValueMap().get("filter").value();
                    String description = parts.toSingleValueMap().get("description") != null
                            ? parts.toSingleValueMap().get("description").value()
                            : null;

                    return imagePart.content().aggregate().asByteArray()
                            .flatMap(bytes -> pyCudaClient.applyFilter(filter, bytes))
                            .flatMap(filteredBytes -> storageClient.uploadPostImage(filteredBytes))
                            .map(imageUrl -> new ImageResult(imageUrl, filter, description));
                });
    }

    // Estrategia 2: mover de temp/ a posts/
    public Mono<String> moveTempToPost(String tempImageId) {
        return storageClient.moveTempToPost(tempImageId); // devuelve imageUrl final
    }

    public static class ImageResult {
        private final String imageUrl;
        private final String filter;
        private final String description;

        public ImageResult(String imageUrl, String filter, String description) {
            this.imageUrl = imageUrl;
            this.filter = filter;
            this.description = description;
        }

        public String getImageUrl() { return imageUrl; }
        public String getFilter() { return filter; }
        public String getDescription() { return description; }
    }
}

PyCudaClient.java (esqueleto)
package ec.ups.upsglam.post.infrastructure.pycuda;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
public class PyCudaClient {

    private final WebClient webClient;

    public PyCudaClient(@Qualifier("pycudaWebClient") WebClient webClient) {
        this.webClient = webClient;
    }

    public Mono<byte[]> applyFilter(String filterName, byte[] imageBytes) {
        return webClient.post()
                .uri("/filters/{filter}", filterName)
                .contentType(MediaType.IMAGE_JPEG)
                .bodyValue(imageBytes)
                .retrieve()
                .bodyToMono(byte[].class);
    }
}

FirebasePostStorageClient.java (esqueleto)
package ec.ups.upsglam.post.infrastructure.storage;

import com.google.cloud.storage.BlobId;
import com.google.cloud.storage.BlobInfo;
import com.google.cloud.storage.Storage;
import ec.ups.upsglam.post.domain.media.model.TempImage;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Component
public class FirebasePostStorageClient {

    private final Storage storage;
    private final String bucketName = "tu-bucket";

    public FirebasePostStorageClient(Storage storage) {
        this.storage = storage;
    }

    public Mono<TempImage> uploadTemp(byte[] filteredBytes) {
        String tempId = "tmp-" + UUID.randomUUID();
        String objectName = "temp/" + tempId + ".jpg";

        return Mono.fromCallable(() -> {
            BlobId blobId = BlobId.of(bucketName, objectName);
            BlobInfo blobInfo = BlobInfo.newBuilder(blobId).setContentType("image/jpeg").build();
            storage.create(blobInfo, filteredBytes);
            String url = generatePublicUrl(objectName);
            return new TempImage(tempId, url);
        });
    }

    public Mono<String> uploadPostImage(byte[] filteredBytes) {
        String postId = "post-" + UUID.randomUUID();
        String objectName = "posts/" + postId + ".jpg";

        return Mono.fromCallable(() -> {
            BlobId blobId = BlobId.of(bucketName, objectName);
            BlobInfo blobInfo = BlobInfo.newBuilder(blobId).setContentType("image/jpeg").build();
            storage.create(blobInfo, filteredBytes);
            return generatePublicUrl(objectName);
        });
    }

    public Mono<String> moveTempToPost(String tempImageId) {
        return Mono.fromCallable(() -> {
            String tempObject = "temp/" + tempImageId + ".jpg";
            String postId = "post-" + UUID.randomUUID();
            String postObject = "posts/" + postId + ".jpg";
            storage.copy(Storage.CopyRequest.of(bucketName, tempObject, bucketName, postObject));
            storage.delete(BlobId.of(bucketName, tempObject));
            return generatePublicUrl(postObject);
        });
    }

    private String generatePublicUrl(String objectName) {
        // versiÃ³n simple, depende de cÃ³mo tengas configurado el bucket
        return "https://firebasestorage.googleapis.com/v0/b/" +
                bucketName + "/o/" + objectName.replace("/", "%2F") + "?alt=media";
    }
}

TempImage.java
package ec.ups.upsglam.post.domain.media.model;

public class TempImage {
    private final String tempImageId;
    private final String imageUrl;

    public TempImage(String tempImageId, String imageUrl) {
        this.tempImageId = tempImageId;
        this.imageUrl = imageUrl;
    }

    public String getTempImageId() { return tempImageId; }
    public String getImageUrl() { return imageUrl; }
}

________________________________________
1.4. Repositorio de POSTS (Firestore)
PostRepository.java (esqueleto)
package ec.ups.upsglam.post.infrastructure.firestore;

import ec.ups.upsglam.post.domain.post.dto.PostResponse;
import reactor.core.publisher.Mono;

public interface PostRepository {

    Mono<FeedPage<PostResponse>> findFeed(int page, int size, String currentUserId);

    Mono<PostResponse> findById(String postId, String currentUserId);

    Mono<PostResponse> saveNewPost(String userId,
                                   String imageUrl,
                                   String filter,
                                   String description);

    Mono<Void> deletePost(String postId, String userId);
}

ImplementaciÃ³n (Firestore usando Mono.fromFuture(...)) puede ir en algo como FirestorePostRepository.java.
________________________________________
2ï¸âƒ£ auth-user-service â€“ esqueletos bÃ¡sicos
AuthRouter.java
package ec.ups.upsglam.auth.api.router;

import ec.ups.upsglam.auth.api.handler.AuthHandler;
import ec.ups.upsglam.auth.api.handler.UserHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;

import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration
public class AuthRouter {

    @Bean
    public RouterFunction<?> authRoutes(AuthHandler authHandler,
                                        UserHandler userHandler) {
        return route(POST("/auth/register"), authHandler::register)
                .andRoute(POST("/auth/login"), authHandler::login)
                .andRoute(GET("/auth/me"), userHandler::me)
                .andRoute(PATCH("/users/me"), userHandler::updateMe)
                .andRoute(PUT("/users/me/avatar"), userHandler::updateAvatar)
                .andRoute(GET("/users/{userId}"), userHandler::getPublicProfile);
    }
}

AuthHandler.java (esqueleto)
package ec.ups.upsglam.auth.api.handler;

import ec.ups.upsglam.auth.domain.service.AuthService;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

@Component
public class AuthHandler {

    private final AuthService authService;

    public AuthHandler(AuthService authService) {
        this.authService = authService;
    }

    public Mono<ServerResponse> register(ServerRequest request) {
        return request.bodyToMono(RegisterRequest.class)
                .flatMap(authService::register)
                .flatMap(response ->
                        ServerResponse.ok()
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(response)
                );
    }

    public Mono<ServerResponse> login(ServerRequest request) {
        return request.bodyToMono(LoginRequest.class)
                .flatMap(authService::login)
                .flatMap(response ->
                        ServerResponse.ok()
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(response)
                );
    }

    public static class RegisterRequest {
        public String email;
        public String password;
        public String fullName;
        public String username;
    }

    public static class LoginRequest {
        public String identifier;
        public String password;
    }
}

AuthService.java (esqueleto)
package ec.ups.upsglam.auth.domain.service;

import ec.ups.upsglam.auth.api.handler.AuthHandler.LoginRequest;
import ec.ups.upsglam.auth.api.handler.AuthHandler.RegisterRequest;
import ec.ups.upsglam.auth.domain.model.User;
import ec.ups.upsglam.auth.infrastructure.firebase.FirebaseAuthClient;
import ec.ups.upsglam.auth.infrastructure.firebase.FirestoreUserRepository;
import reactor.core.publisher.Mono;
import org.springframework.stereotype.Service;

@Service
public class AuthService {

    private final FirebaseAuthClient firebaseAuthClient;
    private final FirestoreUserRepository userRepository;

    public AuthService(FirebaseAuthClient firebaseAuthClient,
                       FirestoreUserRepository userRepository) {
        this.firebaseAuthClient = firebaseAuthClient;
        this.userRepository = userRepository;
    }

    public Mono<AuthResponse> register(RegisterRequest request) {
        // validaciones bÃ¡sicas
        // crear usuario en Firebase Auth
        // crear documento en users/{uid}
        // devolver user + token
        return firebaseAuthClient.createUser(request.email, request.password)
                .flatMap(firebaseUser -> userRepository.createUserProfile(
                                firebaseUser.getUid(),
                                request.email,
                                request.username,
                                request.fullName
                        )
                        .flatMap(user -> firebaseAuthClient.createCustomToken(firebaseUser.getUid())
                                .map(token -> AuthResponse.from(user, token))
                        )
                );
    }

    public Mono<AuthResponse> login(LoginRequest request) {
        // buscar por email/username â†’ email
        // verificar password en Firebase Auth
        // cargar perfil en Firestore
        // devolver user + token
        return firebaseAuthClient.login(request.identifier, request.password)
                .flatMap(firebaseUser -> userRepository.findById(firebaseUser.getUid())
                        .flatMap(user -> firebaseAuthClient.createCustomToken(firebaseUser.getUid())
                                .map(token -> AuthResponse.from(user, token))
                        )
                );
    }

    public static class AuthResponse {
        public User user;
        public Token token;

        public static AuthResponse from(User user, String idToken) {
            AuthResponse res = new AuthResponse();
            res.user = user;
            res.token = new Token(idToken, null, 3600);
            return res;
        }

        public static class Token {
            public String idToken;
            public String refreshToken;
            public int expiresIn;

            public Token(String idToken, String refreshToken, int expiresIn) {
                this.idToken = idToken;
                this.refreshToken = refreshToken;
                this.expiresIn = expiresIn;
            }
        }
    }
}

________________________________________
Con esto ya tienes:
â—	Rutas concretas (RouterFunction).

â—	Handlers concretos (PostHandler, AuthHandler, etc.).

â—	Servicios de dominio (PostService, ImageService, AuthService).

â—	Clientes de infraestructura (PyCudaClient, FirebasePostStorageClient).

Desde aquÃ­ es â€œsoloâ€ ir llenando la lÃ³gica interna, pero la columna vertebral de la arquitectura ya estÃ¡.
Si quieres, en el prÃ³ximo paso podemos elegir un flujo completo (por ejemplo POST /images/preview) y te lo escribo de punta a punta: handler â†’ service â†’ PyCudaClient â†’ Storage, con mÃ¡s detalle en la parte que vayas a implementar primero.

